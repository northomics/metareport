#' wrapper function of rmarkdown::render 
#' 
#'This metareport function provides a way of generting the report on an R server with provided templates, and return the report from a browser or using API. 
#'Of course it works as well on the user end as a stand-alone mode. 
#'Install ningzhibin/rmetalab from github first before usage.
#'
#' @param type string, type of the result to generate the report on, one of summary, peptide,protein,taxon, function
#' @param file string, file name/path of the summary.txt from maxquant result txt folder, mandatory 
#' @param meta string, file name/path of the meta file, optional, a tsv file, generated by MetaLab2.0, 1st columns as sample name, 2nd column as experiment name, 3rd column and after as grouping information.Al columns of grouping information will be ploted repectively, 
#' @param template_version string, can be "latest","stable", or a specific number, like "1.0", "1.1". Default as "stable". Will use the local template in the package (system.file("rmd","MQ_report_summary.Rmd", package = "metareport")), otherwise, it will try to curl the corresponding file from the deposit from either gitlab/github. Besure to use the correct number. If the version defined does not exist, or failed to retrieve from the deposit, it will use the stable version instead.
#' @param url_endpoint if template_version is other than stable, a url_endpoint has to be set corretly, otherwise, a “stable” version will be used instead. see default as example: https://gitlab.com/iMetaLab/rmdocpu/-/raw/master/ if you want to use customized template
#' @param output_format sstring, ee output_format in render, default as html, which has interactivity with plotly support
#' @param output_dir string, see output_dir in render, default as the same path of the rmarkdown input
#' @param output_file string, the name of the output file, default for html document is output.html
#'
#' @return no direct return, but write an output.html to the temp session on the opencpu server
#' @seealso \code{\link{render}}
#' @examples
#'
#' metafile <-system.file("extdata","metainfo.txt", package = "metareport")
#' 
#' ## for summary.txt report
#' datafile <- system.file("extdata","summary.txt", package = "metareport")
#' # generate a report without meta information 
#' metareport(type = "summary", file = datafile, output_dir =  getwd(), output_file = "summary.html" )
#' # generate a report with meta information
#' metareport(type = "summary",file = datafile , meta = metafile, output_dir =  getwd(),output_file = "report_summary.html")
#'
#'
#' ## for peptide.txt report
#' datafile <- system.file("extdata","peptides_report.txt", package = "metareport")
#' # generate a report without meta information 
#' metareport(type = "summary", file = datafile, output_dir =  getwd(), output_file = "summary.html" )
#' # generate a report with meta information
#' metareport(type = "summary",file = datafile , meta = metafile, output_dir =  getwd(),output_file = "report_peptide.html")
#'
#'
#' ## for proteinGroup.txt report
#' datafile <- system.file("extdata","proteinGroups_report.txt", package = "metareport")
#' # generate a report without meta information 
#' metareport(type = "summary", file = datafile, output_dir =  getwd(), output_file = "summary.html" )
#' # generate a report with meta information
#' metareport(type = "summary",file = datafile , meta = metafile, output_dir =  getwd(),output_file = "report_protein.html")
#'
#'
#' ## for taxon report
#' datafile <- system.file("extdata","Builtin.taxa.refine.csv", package = "metareport")
#' # generate a report without meta information 
#' metareport(type = "summary", file = datafile, output_dir =  getwd(), output_file = "summary.html" )
#' # generate a report with meta information
#' metareport(type = "summary",file = datafile , meta = metafile, output_dir =  getwd(),output_file = "report_taxon.html")
#'
#'
#' ## for function report
#' datafile <- system.file("extdata","functions.csv", package = "metareport")
#' # generate a report without meta information 
#' metareport(type = "summary", file = datafile, output_dir =  getwd(), output_file = "summary.html" )
#' # generate a report with meta information
#' metareport(type = "summary",file = datafile , meta = metafile, output_dir =  getwd(),output_file = "report_function.html")
#'
#'
#'
#'
#'
#' @export
#'
#'
#'


metareport <- function(type = "summary", 
                       file, 
                       meta = NULL, 
                       template_version = "stable", 
                       url_endpoint = "https://gitlab.com/iMetaLab/rmdocpu/-/raw/master/", # ends with slash 
                       output_format = "html_document", 
                       output_dir = NULL,
                       output_file = "output.html"
                       ){
  
  
  # choose the right markdown file as input to render
  input_file <- switch(type, 
                       "summary" = "MQ_report_summary.Rmd",
                       "peptide" = "MQ_report_pepides.Rmd",
                       "protein" = "MQ_report_proteinGroups.Rmd",
                       "taxon" = "ML_report_taxonomy.Rmd",
                       "function" = "ML_report_function.Rmd",
                       "mismatch_type.Rmd"
                       
  )
  
  if (template_version == "stable"){    # use the local one
    local_file_path <- system.file("rmd",input_file, package = "metareport")
  } else{
    #myfile <- RCurl::getURL(paste0(url_endpoint,template_version, "/", "MQ_report_summary.Rmd")) # RCurl does not work on windows
    remote_file <- httr::GET(paste0(url_endpoint,template_version, "/", input_file)) #
    
    if( remote_file$status_code == 200){ # if file exists
      writeLines(rawToChar(remote_file$content), con="input.Rmd")
      local_file_path <- "input.Rmd"
    }else{ # use local file if the requested file does not exists
      local_file_path <- system.file("rmd","MQ_report_summary.Rmd", package = "metareport")
      warning('Remote template could not be retrieved, use the stable version on the server instead!')
    }
    
  }

  data_table <- rio::import(file, header = TRUE,check.names = FALSE, stringsAsFactors = FALSE) # read in the data table file
  
  if(!is.null(meta)){
    meta_table <- rio::import(meta, header = TRUE, check.names = FALSE, stringsAsFactors = FALSE) # read in the meta table file
    
    rmarkdown::render(local_file_path,output_format = output_format, params = list(data_table =  data_table, meta_table = meta_table), output_file = output_file, output_dir =  output_dir)
    
  }else{
    rmarkdown::render(local_file_path,output_format = output_format, params = list(data_table =  data_table), output_file = output_file, output_dir =  output_dir)
  }
  
  invisible()
}
